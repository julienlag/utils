#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use lib "$ENV{'ENCODE3_PERLMODS'}";
use lib "/users/rg/jlagarde/julien_utils/";
use indexHashToIndexFile;
use indexFileToHash;
use getEncode3Object;
$Data::Dumper::Sortkeys = 1;
$|=1;
my %indexFileHash=indexFileToHash($ARGV[0]);
#print STDERR Dumper \%indexFileHash;

my @output_types=("alignments", "minusSignal", "MultiMinus", "MultiPlus", "MultiSignal",
"plusSignal", "reads", "reads1", "reads2", "UniqueMinus", "UniquePlus");
my @filePropertiesToOutput=("file_format", "accession", "date_created", "replicate.library", "replicate.biological_replicate_number", "submitted_file_name", "md5sum", "submitted_by.title", "replicate.read_length", "replicate.paired_ended", "library.nucleic_acid_term_name", "library.depleted_in_term_name", "library.size_range");
# files.[].file_format
# files.[].output_type
# files.[].md5sum
# files.[].accession
# files.[].date_created
# files.[].status
# files.[].replicate.biological_replicate_number
# files.[].replicate.library
# files.[].submitted_file_name
# assay_term_name
# accession (experiment's)
# biosample_term_name

# parse commented metadata header from input
my %fileMetadata=();
open F, "$ARGV[0]" or die $!;
while (<F>){
	if ($_=~/^#\s*(\S+)\s+(.+)$/){
		$fileMetadata{$1}=$2;
	}
	elsif($_=~/\S+\t\S+/){ #we've reached data records, end parsing
		last;
	}
}
close F;
#print STDERR Dumper \%fileMetadata;
my @header=('#id','rfa','accession','assay_term_name','biosample_term_name', 'output_type');
push(@header,@filePropertiesToOutput);
print join ("\t", @header);
my @extraHeader=();
foreach my $key (sort keys %fileMetadata){
	push (@extraHeader, "[$key: $fileMetadata{$key}]");
}
print "\t".join("\t", @extraHeader)."\n";

foreach my $acc (keys %indexFileHash){
	# make hash of list of files
	my %files=();
	foreach	my $key (keys %{$indexFileHash{$acc}}){
		#remove quotes:
		${$indexFileHash{$acc}}{$key}=~s/^"//;
		${$indexFileHash{$acc}}{$key}=~s/"$//;

		if($key=~/^files\.(\d+).(\S+)$/){
			$files{$1}{$2}=${$indexFileHash{$acc}}{$key};
		}
	}
#	print STDERR "$acc :\n";
#	print STDERR Dumper \%files;
	foreach my $type (@output_types){
#		print STDERR " $type\n";
		my @generalOutColumns = ($acc, $indexFileHash{$acc}{'award.rfa'}, $indexFileHash{$acc}{'accession'}, $indexFileHash{$acc}{'assay_term_name'}, $indexFileHash{$acc}{'biosample_term_name'}, $type);
		my $output_type_found=0;
		foreach my $file (keys %files){
#			print STDERR "  $file\n";
			if($files{$file}{'output_type'} eq "$type" ){

				$output_type_found++; #incremented each time a file corresponding to $type is found. for paired-end FASTQs we have to output 2 lines. It might be that there are duplicates of other file types (e.g. BAMs submitted by non-gingeras labs)
#				print STDERR "   found $output_type_found times\n";
				my @outColumns=@generalOutColumns;
				foreach my $fileProperty (@filePropertiesToOutput){
					if(exists ($files{$file}{$fileProperty}) && defined ($files{$file}{$fileProperty}) ){
						if($fileProperty eq 'replicate.library'){
							$files{$file}{$fileProperty}=~s/\/libraries\///g;
							$files{$file}{$fileProperty}=~s/\/$//g;

						}
						push(@outColumns, $files{$file}{$fileProperty});
				#print "$files{$file}{'file_format'}\t$files{$file}{'accession'}\t$files{$file}{'date_created'}\t$files{$file}{'replicate.library'}\t$files{$file}{'replicate.biological_replicate_number'}\t$files{$file}{'replicate.library'}\t$files{$file}{'submitted_file_name'}\t$files{$file}{'md5sum'}\n";
					}
					else{
						push(@outColumns, 'not_specified');
					}
				}
				print join ("\t", @outColumns)."\n";
			}
		}
		if($output_type_found == 0){
			my @outColumns=@generalOutColumns;
			foreach my $fileProperty (@filePropertiesToOutput){
				push(@outColumns, ' ');
			}
			#print STDERR "$acc $type not found\n@outColumns\n";

			print join ("\t", @outColumns)."\n";
		}
	}
}
